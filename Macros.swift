//
//  Macros.swift
//  Swift Language Practice - Macros
//
//  This file contains examples demonstrating Swift macros, including
//  freestanding macros, attached macros, and macro expansion.
//

import Foundation

// MARK: - Introduction to Macros

// Macros transform your source code when you compile it, letting you avoid writing repetitive
// code by hand. During compilation, Swift expands any macros in your code before building your
// code as usual.

// Expanding a macro is always an additive operation: Macros add new code, but they never delete
// or modify existing code.

// Both the input to a macro and the output of macro expansion are checked to ensure they're
// syntactically valid Swift code. Likewise, the values you pass to a macro and the values in
// code generated by a macro are checked to ensure they have the correct types. In addition, if
// the macro's implementation encounters an error when expanding that macro, the compiler treats
// this as a compilation error.

// Swift has two kinds of macros:
// - Freestanding macros appear on their own, without being attached to a declaration.
// - Attached macros modify the declaration that they're attached to.

// MARK: - Freestanding Macros

// To call a freestanding macro, you write a number sign (#) before its name, and you write any
// arguments to the macro in parentheses after its name.

func myFunction() {
    print("Currently running \(#function)")
    // #warning("Something's wrong")  // Uncomment to see compile-time warning
}

// In the first line, #function calls the function() macro from the Swift standard library.
// When you compile this code, Swift calls that macro's implementation, which replaces #function
// with the name of the current function. When you run this code and call myFunction(), it prints
// "Currently running myFunction()". In the second line, #warning calls the warning(_:) macro from
// the Swift standard library to produce a custom compile-time warning.

// Freestanding macros can produce a value, like #function does, or they can perform an action at
// compile time, like #warning does.

// Example using #function macro
func exampleFunction() {
    print("Function name: \(#function)")
    print("File: \(#file)")
    print("Line: \(#line)")
    print("Column: \(#column)")
}

// MARK: - Attached Macros

// To call an attached macro, you write an at sign (@) before its name, and you write any arguments
// to the macro in parentheses after its name.

// Attached macros modify the declaration that they're attached to. They add code to that declaration,
// like defining a new method or adding conformance to a protocol.

// For example, consider the following code that doesn't use macros:

struct SundaeToppingsManual: OptionSet {
    let rawValue: Int
    
    static let nuts = SundaeToppingsManual(rawValue: 1 << 0)
    static let cherry = SundaeToppingsManual(rawValue: 1 << 1)
    static let fudge = SundaeToppingsManual(rawValue: 1 << 2)
}

// In this code, each of the options in the SundaeToppings option set includes a call to the
// initializer, which is repetitive and manual. It would be easy to make a mistake when adding a
// new option, like typing the wrong number at the end of the line.

// Here's a version of this code that uses a macro instead (commented out because it requires
// the macro implementation):

// @OptionSet<Int>
// struct SundaeToppings {
//     private enum Options: Int {
//         case nuts
//         case cherry
//         case fudge
//     }
// }

// This version of SundaeToppings calls an @OptionSet macro. The macro reads the list of cases
// in the private enumeration, generates the list of constants for each option, and adds a
// conformance to the OptionSet protocol.

// For comparison, here's what the expanded version of the @OptionSet macro looks like. You don't
// write this code, and you would see it only if you specifically asked Swift to show the macro's
// expansion:

struct SundaeToppingsExpanded {
    private enum Options: Int {
        case nuts
        case cherry
        case fudge
    }
    
    typealias RawValue = Int
    var rawValue: RawValue
    init() { self.rawValue = 0 }
    init(rawValue: RawValue) { self.rawValue = rawValue }
    
    static let nuts: Self = Self(rawValue: 1 << Options.nuts.rawValue)
    static let cherry: Self = Self(rawValue: 1 << Options.cherry.rawValue)
    static let fudge: Self = Self(rawValue: 1 << Options.fudge.rawValue)
}

extension SundaeToppingsExpanded: OptionSet { }

// All of the code after the private enumeration comes from the @OptionSet macro. The version of
// SundaeToppings that uses a macro to generate all of the static variables is easier to read and
// easier to maintain than the manually coded version, earlier.

// MARK: - Macro Declarations

// In most Swift code, when you implement a symbol, like a function or type, there's no separate
// declaration. However, for macros, the declaration and implementation are separate. A macro's
// declaration contains its name, the parameters it takes, where it can be used, and what kind of
// code it generates. A macro's implementation contains the code that expands the macro by generating
// Swift code.

// You introduce a macro declaration with the macro keyword. For example, here's part of the
// declaration for the @OptionSet macro used in the previous example:

// public macro OptionSet<RawType>() =
//         #externalMacro(module: "SwiftMacros", type: "OptionSetMacro")

// The first line specifies the macro's name and its arguments — the name is OptionSet, and it
// doesn't take any arguments. The second line uses the externalMacro(module:type:) macro from
// the Swift standard library to tell Swift where the macro's implementation is located.

// Because OptionSet is an attached macro, its name uses upper camel case, like the names for
// structures and classes. Freestanding macros have lower camel case names, like the names for
// variables and functions.

// Note: Macros are always declared as public. Because the code that declares a macro is in a
// different module from code that uses that macro, there isn't anywhere you could apply a nonpublic
// macro.

// A macro declaration defines the macro's roles — the places in source code where that macro can
// be called, and the kinds of code the macro can generate. Every macro has one or more roles,
// which you write as part of the attributes at the beginning of the macro declaration.

// For example, the @OptionSet macro has these roles:
// @attached(member) - indicates that the macro adds new members to the type you apply it to
// @attached(extension, conformances: OptionSet) - tells you that @OptionSet adds conformance
// to the OptionSet protocol

// For a freestanding macro, you write the @freestanding attribute to specify its role:

// @freestanding(expression)
// public macro line<T: ExpressibleByIntegerLiteral>() -> T =
//         /* ... location of the macro implementation... */

// The #line macro above has the expression role. An expression macro produces a value, or performs
// a compile-time action like generating a warning.

// MARK: - Macro Expansion

// When building Swift code that uses macros, the compiler calls the macros' implementation to
// expand them.

// Specifically, Swift expands macros in the following way:
// 1. The compiler reads the code, creating an in-memory representation of the syntax.
// 2. The compiler sends part of the in-memory representation to the macro implementation, which
//    expands the macro.
// 3. The compiler replaces the macro call with its expanded form.
// 4. The compiler continues with compilation, using the expanded source code.

// To go through the specific steps, consider the following:

// let magicNumber = #fourCharacterCode("ABCD")

// The #fourCharacterCode macro takes a string that's four characters long and returns an unsigned
// 32-bit integer that corresponds to the ASCII values in the string joined together. Some file
// formats use integers like this to identify data because they're compact but still readable in
// a debugger.

// To expand the macros in the code above, the compiler reads the Swift file and creates an
// in-memory representation of that code known as an abstract syntax tree, or AST. The AST makes
// the code's structure explicit, which makes it easier to write code that interacts with that
// structure — like a compiler or a macro implementation.

// As part of constructing this AST, the compiler checks that the source code is valid Swift.
// For example, #fourCharacterCode takes a single argument, which must be a string. If you tried
// to pass an integer argument, or forgot the quotation mark (") at the end of the string literal,
// you'd get an error at this point in the process.

// The compiler finds the places in the code where you call a macro, and loads the external binary
// that implements those macros. For each macro call, the compiler passes part of the AST to that
// macro's implementation.

// Swift helps macro authors avoid accidentally reading other input by restricting the code that
// implements macros:
// - The AST passed to a macro implementation contains only the AST elements that represent the
//   macro, not any of the code that comes before or after it.
// - The macro implementation runs in a sandboxed environment that prevents it from accessing the
//   file system or the network.

// The implementation of #fourCharacterCode generates a new AST containing the expanded code.
// When the compiler receives this expansion, it replaces the AST element that contains the macro
// call with the element that contains the macro's expansion. After macro expansion, the compiler
// checks again to ensure the program is still syntactically valid Swift and all the types are
// correct.

// In this example, the input source code has only one macro, but a real program could have
// several instances of the same macro and several calls to different macros. The compiler expands
// macros one at a time.

// If one macro appears inside another, the outer macro is expanded first — this lets the outer
// macro modify the inner macro before it's expanded.

// MARK: - Implementing a Macro

// To implement a macro, you make two components: A type that performs the macro expansion, and a
// library that declares the macro to expose it as API. These parts are built separately from code
// that uses the macro, even if you're developing the macro and its clients together, because the
// macro implementation runs as part of building the macro's clients.

// To create a new macro using Swift Package Manager, run swift package init --type macro — this
// creates several files, including a template for a macro implementation and declaration.

// The implementation of a macro uses the SwiftSyntax module to interact with Swift code in a
// structured way, using an AST. If you created a new macro package with Swift Package Manager,
// the generated Package.swift file automatically includes a dependency on SwiftSyntax.

// Depending on your macro's role, there's a corresponding protocol from SwiftSyntax that the macro
// implementation conforms to. For example, consider #fourCharacterCode from the previous section.
// Here's a structure that implements that macro:

// Note: The actual implementation would be in a separate macro module. This is a conceptual
// example showing what the implementation would look like:

/*
import SwiftSyntax
import SwiftSyntaxMacros

public struct FourCharacterCode: ExpressionMacro {
    public static func expansion(
        of node: some FreestandingMacroExpansionSyntax,
        in context: some MacroExpansionContext
    ) throws -> ExprSyntax {
        guard let argument = node.argumentList.first?.expression,
              let segments = argument.as(StringLiteralExprSyntax.self)?.segments,
              segments.count == 1,
              case .stringSegment(let literalSegment)? = segments.first
        else {
            throw CustomError.message("Need a static string")
        }

        let string = literalSegment.content.text
        guard let result = fourCharacterCode(for: string) else {
            throw CustomError.message("Invalid four-character code")
        }

        return "\(raw: result) as UInt32"
    }
}

private func fourCharacterCode(for characters: String) -> UInt32? {
    guard characters.count == 4 else { return nil }

    var result: UInt32 = 0
    for character in characters {
        result = result << 8
        guard let asciiValue = character.asciiValue else { return nil }
        result += UInt32(asciiValue)
    }
    return result
}

enum CustomError: Error { case message(String) }
*/

// The #fourCharacterCode macro is a freestanding macro that produces an expression, so the
// FourCharacterCode type that implements it conforms to the ExpressionMacro protocol. The
// ExpressionMacro protocol has one requirement, an expansion(of:in:) method that expands the AST.

// To expand the #fourCharacterCode macro, Swift sends the AST for the code that uses this macro
// to the library that contains the macro implementation. Inside the library, Swift calls
// FourCharacterCode.expansion(of:in:), passing in the AST and the context as arguments to the
// method. The implementation of expansion(of:in:) finds the string that was passed as an argument
// to #fourCharacterCode and calculates the corresponding 32-bit unsigned integer literal value.

// MARK: - Standard Library Macros

// Swift's standard library provides several built-in macros:

// MARK: - #function, #file, #line, #column

// These macros provide information about the current location in source code

func demonstrateLocationMacros() {
    print("Function: \(#function)")
    print("File: \(#file)")
    print("Line: \(#line)")
    print("Column: \(#column)")
}

// MARK: - #warning and #error

// These macros generate compile-time warnings and errors

func demonstrateWarningAndError() {
    // #warning("This is a compile-time warning")
    // #error("This is a compile-time error that stops compilation")
    print("This function demonstrates warning and error macros")
}

// MARK: - #if and #available

// Conditional compilation macros

#if DEBUG
    let isDebugMode = true
#else
    let isDebugMode = false
#endif

// MARK: - Practical Examples

// MARK: - Example: Using Standard Library Macros

func logMessage(_ message: String) {
    print("[\(#file):\(#line)] \(#function): \(message)")
}

// MARK: - Example: Debug Information

struct DebugInfo {
    static func printCurrentLocation() {
        print("Current location:")
        print("  File: \(#file)")
        print("  Function: \(#function)")
        print("  Line: \(#line)")
    }
}

// MARK: - Example: Conditional Compilation

#if os(macOS)
    let platformName = "macOS"
#elseif os(iOS)
    let platformName = "iOS"
#elseif os(Linux)
    let platformName = "Linux"
#else
    let platformName = "Unknown"
#endif

// MARK: - Example: Version Checking

#if swift(>=5.9)
    let supportsMacros = true
#else
    let supportsMacros = false
#endif

// MARK: - Example Function Demonstrating All Macro Concepts

func demonstrateMacros() {
    print("\n=== Demonstrating Swift Macros ===\n")
    
    // Location macros
    print("1. Location Macros:")
    demonstrateLocationMacros()
    
    // Function name macro
    print("\n2. Function Name Macro:")
    myFunction()
    
    // Debug info
    print("\n3. Debug Information:")
    DebugInfo.printCurrentLocation()
    
    // Logging with macros
    print("\n4. Logging with Macros:")
    logMessage("This is a test message")
    
    // Conditional compilation
    print("\n5. Conditional Compilation:")
    print("  Platform: \(platformName)")
    print("  Supports Macros: \(supportsMacros)")
    print("  Debug Mode: \(isDebugMode)")
    
    // OptionSet examples
    print("\n6. OptionSet Examples:")
    let toppings1 = SundaeToppingsManual.nuts
    let toppings2: SundaeToppingsManual = [.nuts, .cherry]
    print("  Toppings 1: \(toppings1.rawValue)")
    print("  Toppings 2: \(toppings2.rawValue)")
    
    print("\n=== End of Demonstration ===\n")
}

// Uncomment to run the demonstration
// demonstrateMacros()

// MARK: - Notes on Macro Implementation

/*
 To implement a macro, you typically need:
 
 1. A Package.swift file with:
    - Swift tools version 5.9 or later
    - Import CompilerPluginSupport
    - Dependencies on swift-syntax
    - A macro target and a library target
 
 2. A macro implementation that conforms to a protocol like:
    - ExpressionMacro for freestanding expression macros
    - DeclarationMacro for freestanding declaration macros
    - MemberMacro for attached member macros
    - ExtensionMacro for attached extension macros
    - etc.
 
 3. A macro declaration that uses #externalMacro to point to the implementation
 
 4. A CompilerPlugin that lists all the macros provided by the module
 
 Example Package.swift structure:
 
 // swift-tools-version: 5.9
 import PackageDescription
 import CompilerPluginSupport
 
 let package = Package(
     name: "MyPackage",
     platforms: [.macOS(.v13)],
     dependencies: [
         .package(url: "https://github.com/swiftlang/swift-syntax", from: "509.0.0")
     ],
     targets: [
         .macro(
             name: "MyPackageMacros",
             dependencies: [
                 .product(name: "SwiftSyntaxMacros", package: "swift-syntax"),
                 .product(name: "SwiftCompilerPlugin", package: "swift-syntax")
             ]
         ),
         .target(
             name: "MyPackage",
             dependencies: ["MyPackageMacros"]
         )
     ]
 )
 
 Example macro implementation structure:
 
 import SwiftSyntax
 import SwiftSyntaxMacros
 
 public struct MyMacro: ExpressionMacro {
     public static func expansion(
         of node: some FreestandingMacroExpansionSyntax,
         in context: some MacroExpansionContext
     ) throws -> ExprSyntax {
         // Implementation here
         return "/* generated code */"
     }
 }
 
 Example CompilerPlugin:
 
 import SwiftCompilerPlugin
 
 @main
 struct MyPackageMacros: CompilerPlugin {
     var providingMacros: [Macro.Type] = [
         MyMacro.self
     ]
 }
 
 Example macro declaration:
 
 @freestanding(expression)
 public macro myMacro() -> String =
     #externalMacro(module: "MyPackageMacros", type: "MyMacro")
 */


